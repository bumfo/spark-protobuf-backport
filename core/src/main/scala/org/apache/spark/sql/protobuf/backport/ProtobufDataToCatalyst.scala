/*
 * Backport of Spark 3.4's ProtobufDataToCatalyst to Spark 3.2.1.
 *
 * This version has been enhanced to support deserializing Protobuf
 * binaries directly into Spark's InternalRow without going through
 * DynamicMessage when a compiled Java class is available.  When the
 * message name points at a generated Protobuf Java class (and neither
 * a descriptor file path nor a binary descriptor set is provided) we
 * use reflection to load the class, parse the binary using the
 * class's static `parseFrom` method and then convert the resulting
 * message into an InternalRow using a Parser generated by
 * fastproto.ProtoToRowGenerator.  This avoids the overhead of
 * DynamicMessage and allows users to work with compiled messages.
 */

package org.apache.spark.sql.protobuf.backport

import com.google.protobuf.{Message => PbMessage}
import fastproto.{Parser, ProtoToRowGenerator, StreamWireParser, WireFormatToRowGenerator}
import org.apache.spark.sql.catalyst.expressions.codegen.{CodeGenerator, CodegenContext, ExprCode}
import org.apache.spark.sql.catalyst.expressions.{ExpectsInputTypes, Expression, UnaryExpression}
import org.apache.spark.sql.catalyst.util.{FailFastMode, ParseMode, PermissiveMode}
import org.apache.spark.sql.protobuf.backport.shims.{QueryCompilationErrors, QueryExecutionErrors}
import org.apache.spark.sql.protobuf.backport.utils.{ProtobufOptions, ProtobufUtils, SchemaConverters}
import org.apache.spark.sql.types.{AbstractDataType, BinaryType, StructType}

import scala.util.control.NonFatal

/**
 * A Catalyst expression that deserializes a Protobuf binary column into a
 * Catalyst value.  If parsing fails it either returns null (permissive mode)
 * or throws an exception (fail‑fast mode).
 *
 * When a compiled Protobuf class is available (i.e. `messageName` refers
 * directly to a Java class and both `descFilePath` and `binaryDescriptorSet`
 * are empty) the binary is parsed using the class's `parseFrom` method and
 * converted into an InternalRow via a generated [[fastproto.Parser]].
 * Otherwise this falls back to Spark's original DynamicMessage‑based
 * deserialization path.
 *
 * @param child               The binary column to deserialize.
 * @param messageName         The fully qualified message name or Java class name.
 * @param descFilePath        Optional path to a serialized descriptor file.  If
 *                            provided the descriptor will be loaded from the file;
 *                            otherwise `messageName` is treated as a Java class name.
 * @param options             Reader options; currently supports "mode" (permissive|failfast)
 *                            and "recursive.fields.max.depth".
 * @param binaryDescriptorSet Optional binary descriptor set.  If defined, this
 *                            descriptor will be used to build the message descriptor
 *                            instead of reading from a file on the executors.  This
 *                            allows the descriptor to be serialized with the
 *                            expression and avoids file availability issues.
 */
private[backport] case class ProtobufDataToCatalyst(
    child: Expression,
    messageName: String,
    descFilePath: Option[String] = None,
    options: Map[String, String] = Map.empty,
    binaryDescriptorSet: Option[Array[Byte]] = None)
  extends UnaryExpression
    with ExpectsInputTypes {

  override def inputTypes: Seq[AbstractDataType] = Seq(BinaryType)

  override lazy val dataType: StructType =
    SchemaConverters.toSqlType(messageDescriptor, protobufOptions).dataType

  override def nullable: Boolean = true

  private lazy val protobufOptions = ProtobufOptions(options)

  @transient private lazy val messageDescriptor: com.google.protobuf.Descriptors.Descriptor =
    binaryDescriptorSet match {
      case Some(bytes) => ProtobufUtils.buildDescriptorFromBytes(bytes, messageName)
      case None => ProtobufUtils.buildDescriptor(messageName, descFilePath)
    }

  // Determine parse mode once up front.
  @transient private lazy val parseMode: ParseMode = {
    val mode = protobufOptions.parseMode
    if (mode != PermissiveMode && mode != FailFastMode) {
      throw QueryCompilationErrors.parseModeUnsupportedError(prettyName, mode)
    }
    mode
  }

  /**
   * Lazily attempt to load the compiled Protobuf class if the messageName
   * refers to a Java class.  Only do this when no descriptor file or binary
   * descriptor set is provided, otherwise messageName refers to a descriptor
   * symbol rather than a class.  Any errors during class loading are
   * swallowed and result in [[None]], causing the DynamicMessage path to be
   * used instead.
   */
  @transient private lazy val messageClassOpt: Option[Class[PbMessage]] = {
    (descFilePath, binaryDescriptorSet) match {
      case (None, None) =>
        try {
          Some(Class.forName(messageName).asInstanceOf[Class[PbMessage]])
        } catch {
          case _: Throwable => None
        }
      case _ => None
    }
  }

  /**
   * Lazily create a [[fastproto.MessageParser]] for the compiled message class.
   * The parser uses the descriptor corresponding to this expression (from
   * either the provided binary descriptor set or `ProtobufUtils.buildDescriptor`)
   * so that the schema matches the Catalyst data type.  If the message class
   * cannot be loaded this will be [[None]].
   */
  @transient private lazy val messageParserOpt: Option[Parser] = messageClassOpt.map { cls =>
    // Use the descriptor used to compute the Catalyst schema so that
    // the row parser's schema matches the Catalyst data type.  Cast
    // the generated parser to Parser[PbMessage] since PbMessage
    // is a supertype of all generated protobuf classes.
    ProtoToRowGenerator.generateParser(messageDescriptor, cls)
  }

  /**
   * Lazily create a generated [[fastproto.StreamWireParser]] for binary descriptor sets.
   * This provides an optimized fast path for direct wire format parsing when using binary
   * descriptor sets, avoiding DynamicMessage overhead. Uses code generation to create
   * optimized parsers with inlined field parsing and JIT-friendly branch prediction.
   * Falls back to DynamicMessage if code generation fails.
   */
  @transient private lazy val wireFormatParserOpt: Option[StreamWireParser] = binaryDescriptorSet match {
    // todo always prefer wireFormatParser
    case Some(_) =>
      // Generate optimized parser using code generation
      Some(WireFormatToRowGenerator.generateParser(messageDescriptor, dataType))
    case None => None
  }

  /**
   * Lazily create a [[DynamicMessageParser]] for the fallback DynamicMessage path.
   * This parser wraps the existing ProtobufDeserializer logic and is used when neither
   * compiled class nor wire format parsers are available. It provides a consistent
   * Parser interface while maintaining the original DynamicMessage deserialization behavior.
   */
  @transient private lazy val dynamicMessageParserOpt: Option[Parser] = {
    // Create when no other fast paths are available
    if (messageParserOpt.isEmpty && wireFormatParserOpt.isEmpty) {
      Some(new DynamicMessageParser(messageDescriptor, dataType))
    } else {
      None
    }
  }

  /**
   * Handle an exception according to the configured parse mode.
   */
  private def handleException(e: Throwable): Any = {
    e match {
      case _: org.codehaus.commons.compiler.CompileException =>
        throw e
      case NonFatal(_) =>
        parseMode match {
          case PermissiveMode => null
          case FailFastMode =>
            throw QueryExecutionErrors.malformedProtobufMessageDetectedInMessageParsingError(e)
          case _ =>
            throw QueryCompilationErrors.parseModeUnsupportedError(prettyName, parseMode)
        }
    }
  }

  override def nullSafeEval(input: Any): Any = {
    val binary = input.asInstanceOf[Array[Byte]]
    try {
      // Try parsers in priority order:
      // 1. Compiled class parser (messageParserOpt)
      // 2. Wire format parser (wireFormatParserOpt)
      // 3. DynamicMessage parser (dynamicMessageParserOpt)
      val parser = messageParserOpt
        .orElse(wireFormatParserOpt)
        .orElse(dynamicMessageParserOpt)
        .getOrElse(throw new IllegalStateException("No parser available"))

      parser.parse(binary)
    } catch {
      case NonFatal(e) => handleException(e)
    }
  }

  override def prettyName: String = "from_protobuf"

  override protected def doGenCode(ctx: CodegenContext, ev: ExprCode): ExprCode = {
    // Check if we can generate optimized code using any available parser
    val parserOpt = messageParserOpt
      .orElse(wireFormatParserOpt)
      .orElse(dynamicMessageParserOpt)

    parserOpt match {
      case Some(parser) =>
        // Generate optimized code path using the parser directly
        val expr = ctx.addReferenceObj("this", this)
        val converterRef = ctx.addReferenceObj("parser", parser)

        nullSafeCodeGen(
          ctx,
          ev,
          eval => {
            val result = ctx.freshName("result")
            val dt = CodeGenerator.boxedType(dataType)
            s"""
               |// Optimized codegen path using parser with direct binary conversion
               |try {
               |  $dt $result = ($dt) $converterRef.convert($eval);
               |  if ($result == null) {
               |    ${ev.isNull} = true;
               |  } else {
               |    ${ev.value} = $result;
               |  }
               |} catch (java.lang.Exception e) {
               |  $expr.handleException(e);
               |  ${ev.isNull} = true;
               |}
               |""".stripMargin
          }
        )
      case None =>
        // Fallback to standard codegen path that calls nullSafeEval
        val expr = ctx.addReferenceObj("this", this)
        nullSafeCodeGen(
          ctx,
          ev,
          eval => {
            val result = ctx.freshName("result")
            val dt = CodeGenerator.boxedType(dataType)
            s"""
               |$dt $result = ($dt) $expr.nullSafeEval($eval);
               |if ($result == null) {
               |  ${ev.isNull} = true;
               |} else {
               |  ${ev.value} = $result;
               |}
               |""".stripMargin
          }
        )
    }
  }

  override protected def withNewChildInternal(newChild: Expression): ProtobufDataToCatalyst =
    copy(child = newChild)
}
