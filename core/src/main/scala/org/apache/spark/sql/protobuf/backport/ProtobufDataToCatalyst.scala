/*
 * Backport of Spark 3.4's ProtobufDataToCatalyst to Spark 3.2.1.
 *
 * This version has been enhanced to support deserializing Protobuf
 * binaries directly into Spark's InternalRow without going through
 * DynamicMessage when a compiled Java class is available.  When the
 * message name points at a generated Protobuf Java class (and neither
 * a descriptor file path nor a binary descriptor set is provided) we
 * use reflection to load the class, parse the binary using the
 * class's static `parseFrom` method and then convert the resulting
 * message into an InternalRow using a RowConverter generated by
 * fastproto.ProtoToRowGenerator.  This avoids the overhead of
 * DynamicMessage and allows users to work with compiled messages.
 */

package org.apache.spark.sql.protobuf.backport

import com.google.protobuf.{Message => PbMessage}
import fastproto.{AbstractRowConverter, ProtoToRowGenerator, RowConverter, WireFormatToRowGenerator}
import org.apache.spark.sql.catalyst.expressions.codegen.{CodeGenerator, CodegenContext, ExprCode}
import org.apache.spark.sql.catalyst.expressions.{ExpectsInputTypes, Expression, UnaryExpression}
import org.apache.spark.sql.catalyst.util.{FailFastMode, ParseMode, PermissiveMode}
import org.apache.spark.sql.protobuf.backport.shims.{QueryCompilationErrors, QueryExecutionErrors}
import org.apache.spark.sql.protobuf.backport.utils.{ProtobufOptions, ProtobufUtils, SchemaConverters}
import org.apache.spark.sql.types.{AbstractDataType, BinaryType, StructType}

import scala.util.control.NonFatal

/**
 * A Catalyst expression that deserializes a Protobuf binary column into a
 * Catalyst value.  If parsing fails it either returns null (permissive mode)
 * or throws an exception (fail‑fast mode).
 *
 * When a compiled Protobuf class is available (i.e. `messageName` refers
 * directly to a Java class and both `descFilePath` and `binaryDescriptorSet`
 * are empty) the binary is parsed using the class's `parseFrom` method and
 * converted into an InternalRow via a generated [[fastproto.RowConverter]].
 * Otherwise this falls back to Spark's original DynamicMessage‑based
 * deserialization path.
 *
 * @param child               The binary column to deserialize.
 * @param messageName         The fully qualified message name or Java class name.
 * @param descFilePath        Optional path to a serialized descriptor file.  If
 *                            provided the descriptor will be loaded from the file;
 *                            otherwise `messageName` is treated as a Java class name.
 * @param options             Reader options; currently supports "mode" (permissive|failfast)
 *                            and "recursive.fields.max.depth".
 * @param binaryDescriptorSet Optional binary descriptor set.  If defined, this
 *                            descriptor will be used to build the message descriptor
 *                            instead of reading from a file on the executors.  This
 *                            allows the descriptor to be serialized with the
 *                            expression and avoids file availability issues.
 */
private[backport] case class ProtobufDataToCatalyst(
    child: Expression,
    messageName: String,
    descFilePath: Option[String] = None,
    options: Map[String, String] = Map.empty,
    binaryDescriptorSet: Option[Array[Byte]] = None)
  extends UnaryExpression
    with ExpectsInputTypes {

  override def inputTypes: Seq[AbstractDataType] = Seq(BinaryType)

  override lazy val dataType: StructType =
    SchemaConverters.toSqlType(messageDescriptor, protobufOptions).dataType

  override def nullable: Boolean = true

  private lazy val protobufOptions = ProtobufOptions(options)

  @transient private lazy val messageDescriptor: com.google.protobuf.Descriptors.Descriptor =
    binaryDescriptorSet match {
      case Some(bytes) => ProtobufUtils.buildDescriptorFromBytes(bytes, messageName)
      case None => ProtobufUtils.buildDescriptor(messageName, descFilePath)
    }

  // Determine parse mode once up front.
  @transient private lazy val parseMode: ParseMode = {
    val mode = protobufOptions.parseMode
    if (mode != PermissiveMode && mode != FailFastMode) {
      throw QueryCompilationErrors.parseModeUnsupportedError(prettyName, mode)
    }
    mode
  }

  /**
   * Lazily attempt to load the compiled Protobuf class if the messageName
   * refers to a Java class.  Only do this when no descriptor file or binary
   * descriptor set is provided, otherwise messageName refers to a descriptor
   * symbol rather than a class.  Any errors during class loading are
   * swallowed and result in [[None]], causing the DynamicMessage path to be
   * used instead.
   */
  @transient private lazy val messageClassOpt: Option[Class[PbMessage]] = {
    (descFilePath, binaryDescriptorSet) match {
      case (None, None) =>
        try {
          Some(Class.forName(messageName).asInstanceOf[Class[PbMessage]])
        } catch {
          case _: Throwable => None
        }
      case _ => None
    }
  }

  /**
   * Lazily create a [[fastproto.RowConverter]] for the compiled message class.
   * The converter uses the descriptor corresponding to this expression (from
   * either the provided binary descriptor set or `ProtobufUtils.buildDescriptor`)
   * so that the schema matches the Catalyst data type.  If the message class
   * cannot be loaded this will be [[None]].
   */
  @transient private lazy val rowConverterOpt: Option[RowConverter] =
  messageClassOpt.map { cls =>
    // Use the descriptor used to compute the Catalyst schema so that
    // the row converter's schema matches the Catalyst data type.  Cast
    // the generated converter to RowConverter[PbMessage] since PbMessage
    // is a supertype of all generated protobuf classes.
    val desc: com.google.protobuf.Descriptors.Descriptor = messageDescriptor
    ProtoToRowGenerator
      .generateConverter(desc, cls)
  }

  /**
   * Lazily create a generated [[fastproto.AbstractWireFormatConverter]] for binary descriptor sets.
   * This provides an optimized fast path for direct wire format parsing when using binary
   * descriptor sets, avoiding DynamicMessage overhead. Uses code generation to create
   * optimized converters with inlined field parsing and JIT-friendly branch prediction.
   * Falls back to DynamicMessage if code generation fails.
   */
  @transient private lazy val wireFormatConverterOpt: Option[AbstractRowConverter] =
    binaryDescriptorSet match {
      case Some(_) =>
        try {
          // Convert DataType to StructType for WireFormatConverter
          val structType = dataType
          // Generate optimized converter using code generation
          Some(WireFormatToRowGenerator.generateConverter(messageDescriptor, structType))
        } catch {
          case _: Throwable => None // Fall back to DynamicMessage for unsupported cases
        }
      case None => None
    }

  /**
   * Lazily create a [[DynamicMessageConverter]] for the fallback DynamicMessage path.
   * This converter wraps the existing ProtobufDeserializer logic and is used when neither
   * compiled class nor wire format converters are available. It provides a consistent
   * RowConverter interface while maintaining the original DynamicMessage deserialization behavior.
   */
  @transient private lazy val dynamicMessageConverterOpt: Option[RowConverter] = {
    // Create when no other fast paths are available
    if (rowConverterOpt.isEmpty && wireFormatConverterOpt.isEmpty) {
      Some(new DynamicMessageConverter(messageDescriptor, dataType))
    } else {
      None
    }
  }

  /**
   * Handle an exception according to the configured parse mode.
   */
  private def handleException(e: Throwable): Any = {
    e match {
      case _: org.codehaus.commons.compiler.CompileException =>
        throw e
      case NonFatal(_) =>
        parseMode match {
          case PermissiveMode => null
          case FailFastMode =>
            throw QueryExecutionErrors.malformedProtobufMessageDetectedInMessageParsingError(e)
          case _ =>
            throw QueryCompilationErrors.parseModeUnsupportedError(prettyName, parseMode)
        }
    }
  }

  override def nullSafeEval(input: Any): Any = {
    val binary = input.asInstanceOf[Array[Byte]]
    try {
      // Try converters in priority order:
      // 1. Compiled class converter (rowConverterOpt)
      // 2. Wire format converter (wireFormatConverterOpt)
      // 3. DynamicMessage converter (dynamicMessageConverterOpt)
      val converter = rowConverterOpt
        .orElse(wireFormatConverterOpt)
        .orElse(dynamicMessageConverterOpt)
        .getOrElse(throw new IllegalStateException("No converter available"))

      converter.convert(binary)
    } catch {
      case NonFatal(e) => handleException(e)
    }
  }

  override def prettyName: String = "from_protobuf"

  override protected def doGenCode(ctx: CodegenContext, ev: ExprCode): ExprCode = {
    // Check if we can generate optimized code using any available converter
    val converterOpt = rowConverterOpt
      .orElse(wireFormatConverterOpt)
      .orElse(dynamicMessageConverterOpt)

    converterOpt match {
      case Some(converter) =>
        // Generate optimized code path using the RowConverter directly
        val expr = ctx.addReferenceObj("this", this)
        val converterRef = ctx.addReferenceObj("rowConverter", converter)

        nullSafeCodeGen(
          ctx,
          ev,
          eval => {
            val result = ctx.freshName("result")
            val dt = CodeGenerator.boxedType(dataType)
            s"""
               |// Optimized codegen path using RowConverter with direct binary conversion
               |try {
               |  $dt $result = ($dt) $converterRef.convert($eval);
               |  if ($result == null) {
               |    ${ev.isNull} = true;
               |  } else {
               |    ${ev.value} = $result;
               |  }
               |} catch (java.lang.Exception e) {
               |  $expr.handleException(e);
               |  ${ev.isNull} = true;
               |}
               |""".stripMargin
          }
        )
      case None =>
        // Fallback to standard codegen path that calls nullSafeEval
        val expr = ctx.addReferenceObj("this", this)
        nullSafeCodeGen(
          ctx,
          ev,
          eval => {
            val result = ctx.freshName("result")
            val dt = CodeGenerator.boxedType(dataType)
            s"""
               |$dt $result = ($dt) $expr.nullSafeEval($eval);
               |if ($result == null) {
               |  ${ev.isNull} = true;
               |} else {
               |  ${ev.value} = $result;
               |}
               |""".stripMargin
          }
        )
    }
  }

  override protected def withNewChildInternal(newChild: Expression): ProtobufDataToCatalyst =
    copy(child = newChild)
}
